<!DOCTYPE html>
<!--
  ~ Copyright 2016-2017 Red Hat, Inc, and individual contributors.
  ~  Licensed under the Apache License, Version 2.0 (the "License");
  ~  you may not use this file except in compliance with the License.
  ~  You may obtain a copy of the License at
  ~  http://www.apache.org/licenses/LICENSE-2.0
  ~  Unless required by applicable law or agreed to in writing, software
  ~  distributed under the License is distributed on an "AS IS" BASIS,
  ~  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~  See the License for the specific language governing permissions and
  ~  limitations under the License.
  -->
<html>

<head>
  <meta charset="utf-8">
  <title>Health Check Example - Node.js</title>
  <link rel="stylesheet" type="text/css"
    href="https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/css/patternfly.min.css">
</head>

<body>
  <div id="app" class="container">
    <div>
      <div class="sect1">
        <h2>Health Check Example</h2>
        <div class="sectionbody">
          <div class="paragraph">
            <p>Demonstrates how the Kubernetes health checks work to determine if a container is still alive (the
              <em>liveness</em> of the container) and ready to serve the traffic for the HTTP endpoints of the
              application (the <em>readiness</em> of the container).</p>
          </div>
          <div class="paragraph">
            <p>To demonstrate this behavior, the application configures a <code>/health</code> HTTP endpoint, which is
              used
              by Kubernetes to issue HTTP requests. If the container is still alive
              which means the Health HTTP endpoint
              is able to reply
              the management platform will receive HTTP code 200 as a response, and no further action
              is taken. After you click the
              <code>Stop Service</code> button, the HTTP endpoint stops returning a response, and the platform then
              restarts
              the pod with the unresponsive container. While the pod is down, the example UI polls the service
              periodically
              until the pod is restarted. In the meantime, do <strong>not</strong> refresh the page because it will
              not be served until the pod finishes restarting.
            </p>
          </div>
          <div class="sect2">
            <h3>Using the greeting service</h3>
          </div>
        </div>
      </div>
      <div class="form-group">
        <label for="name">Name</label>
        <input type="text" class="form-control" ref="name" id="name" placeholder="World">
      </div>
      <button id="invoke" class="btn btn-success" @click="getJSON">Invoke</button>
      <button id="stop" type="submit" class="btn btn-danger" @click="stop">Stop Service</button>
      <h3>Result:</h3>
      <pre><code id="greeting-result">{{greetingResult}}</code></pre>
    </div>
  </div>
  <!-- 
<script>
    let stopTime;
    let attempts;
    function invokeService() {
        const n = $("#name").val() || "World";
        $.getJSON("/api/greeting?name=" + n, function (res) {
            $("#greeting-result").html(JSON.stringify(res));
        });
    }
    function invokeServiceandRetryUponFailures() {
        const n = $("#name").val() || "World";
        $.getJSON("/api/greeting?name=" + n, function (res) {
            const rebirth = new Date();
            const diff = (stopTime.getTime() - rebirth.getTime()) / 1000;
            const abs = Math.abs(diff);
            $("#greeting-result").html(JSON.stringify(res) + " (the recovery took " + abs + " seconds)");
        })
            .fail(function () {
                $("#greeting-result").html("[" + ++attempts + "] Service not available... Retrying in 2 seconds");
                setTimeout(invokeServiceandRetryUponFailures, 2000);
            });
    }
    $(document).ready(function() {
        $("#invoke").click(function (e) {
            invokeService();
            e.preventDefault();
        });
        $("#stop").click(function (e) {
            $.get( "/api/stop", function( data ) {
                $("#greeting-result").html("The application has been stopped...");
                stopTime = new Date();
                attempts = 0;
                setTimeout(invokeServiceandRetryUponFailures, 2000);
            });
            e.preventDefault();
        });
    });
</script> -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/2.7.10/vue.min.js"
    integrity="sha512-H8u5mlZT1FD7MRlnUsODppkKyk+VEiCmncej8yZW1k/wUT90OQon0F9DSf/2Qh+7L/5UHd+xTLrMszjHEZc2BA=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script>
    // Lets use Vue 2 because it is more mature and
    // already have a lot of resources around internet
    // related to this specific way of usage via CDN 
    // instead of full complete vue app.
    const app = new Vue({
      // reference to the div app
      el: '#app',
      data: {
        // Stop time and attempts variables to replicate the example. 
        stopTime: null,
        attempts: 0,
        // The initial value text on the greeting result.
        greetingResult: 'Invoke the service to see the result.'
      },
      methods: {
        // Operations/methods to be trigged when clicking in the buttons
        async getJSON() {
          // This way we get the value of the input.
          // We need to add ref="name" to the input text.
          const name = this.$refs.name.value;
          // Let's use native fetch browser implementation with async/await
          // instead of JQuery AJAX.
          const result = await fetch(`/api/greeting?name=${name}`);
          // Let's check the result to improve a bit.
          if (!result.ok) {
            const message = `Error: ${result.status} - ${result.statusText}`;
            throw new Error(message);
          }
          // Getting the result as JSON format to be updated later on the
          // greetingResult.
          const data = await result.json();
          this.greetingResult = JSON.stringify(data);
        },
        async invokeServiceAndRetryUponFailures() {
          const name = this.$refs.name.value;
          // Lets use then -> catch approach to handle the failure.
          const result = await fetch(`/api/greeting?name=${name}`);
          if (!result.ok) {
            this.attempts = this.attempts + 1;
            this.greetingResult = `[${this.attempts}] Service not available... Retrying in 2 seconds`;
            setTimeout(this.invokeServiceAndRetryUponFailures, 2000);
          } else {
            const rebirth = new Date();
            const diff = (this.stopTime.getTime() - rebirth.getTime()) / 1000;
            const abs = Math.abs(diff);
            // Let's use proper template strings.
            this.greetingResult = `${JSON.stringify(result)} (the recovery took ${abs} seconds)`;
          }
        },
        stop() {
          const res = fetch('/api/stop')
            .then(result => {
              this.greetingResult = 'The application has been stopped...';
              this.stopTime = new Date();
              this.attempts = 0;
              setTimeout(this.invokeServiceAndRetryUponFailures, 2000);
            }).catch(error => {
              console.error(error);
            });
        }
      }
    });
  </script>
</body>
</html>
